package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
)

type SQLParam struct {
	Name  string
	Index int
}

type SQLFile struct {
	Path       string
	Key        string
	Content    string
	Name       string
	Params     map[string]SQLParam
	ReboundSQL string
}

// Run finds all .sql files recursively starting at sqlRootDir, parses, and constructs
// go code that is written to the underlying writer.
func Run(packageName string, sqlRootDir string, writer io.Writer) error {
	files, err := findSQLFiles(sqlRootDir)
	if err != nil {
		fmt.Println(err)
		return err
	}

	generatedCode := generateGoCode(packageName, files)

	if _, err := writer.Write([]byte(generatedCode)); err != nil {
		fmt.Println(err)
		return err
	}

	return nil
}

func generateGoCode(packageName string, tinySQLFiles map[string][]SQLFile) string {
	source := bytes.NewBufferString("")

	err := mapTemplate.Execute(source, struct {
		PackageName string
		Roots       map[string][]SQLFile
	}{
		PackageName: packageName,
		Roots:       tinySQLFiles,
	})

	if err != nil {
		panic(err)
	}

	formattedBytes, err := format.Source(source.Bytes())

	if err != nil {
		panic(err)
	}

	return string(formattedBytes)
}

func makeParams(params []string) map[string]SQLParam {
	result := make(map[string]SQLParam)
	for i, p := range params {
		result[p] = SQLParam{
			Name:  p,
			Index: i + 1,
		}
	}
	return result
}

func findSQLFiles(root string) (map[string][]SQLFile, error) {
	tinySQLFiles := make(map[string][]SQLFile)

	absPath, err := filepath.Abs(root)
	if err != nil {
		return nil, err
	}

	sqlFiles, _ := filepath.Glob(absPath + "/**/*.sql")

	for _, path := range sqlFiles {
		relativePath := strings.Replace(path, absPath+string(filepath.Separator), "", 1)
		relativePath = strings.Replace(relativePath, ".sql", "", 1)

		pathParts := strings.Split(relativePath, string(filepath.Separator))

		for i, p := range pathParts {
			pathParts[i] = strcase.ToCamel(p)
		}

		sqlKey := strcase.ToCamel(strings.Join(pathParts, "_"))

		content, err := ioutil.ReadFile(path)
		if err != nil {
			return nil, err
		}

		sqlSource := string(content)
		newSQL, params, err := Parse([]byte(sqlSource), DOLLAR, true)
		if err != nil {
			return nil, err
		}

		tinyParams := makeParams(params)

		tinySQL := SQLFile{
			Path:       path,
			Name:       pathParts[1],
			Key:        sqlKey,
			Params:     tinyParams,
			Content:    sqlSource,
			ReboundSQL: newSQL,
		}

		if items, ok := tinySQLFiles[pathParts[0]]; ok {
			tinySQLFiles[pathParts[0]] = append(items, tinySQL)
		} else {
			var thing []SQLFile
			tinySQLFiles[pathParts[0]] = append(thing, tinySQL)
		}
	}

	return tinySQLFiles, nil
}

func sortParams(p map[string]SQLParam) []SQLParam {
	var params []SQLParam

	for _, v := range p {
		params = append(params, v)
	}

	sort.Slice(params, func(i, j int) bool {
		return params[i].Index < params[j].Index
	})

	return params
}

var mapTemplate = template.Must(template.New("").Funcs(template.FuncMap{
	"ToCamel":      strcase.ToCamel,
	"ToLowerCamel": strcase.ToLowerCamel,
	"SortParams":   sortParams,
}).Parse(`// Code generated by go generate; DO NOT EDIT.
package {{ .PackageName }}

{{- range $k, $v := .Roots }}
{{- range $v }}
type {{ $k }}{{ .Name }} struct {
	{{- range $paramName, $_ := .Params }}
		{{ ToCamel $paramName }} interface{}
	{{- end }}
}
{{ end }}
{{ end -}}

{{ range $k, $v := .Roots }}
{{- range $v }}
func (p {{ $k }}{{ .Name }}) Build() (string, []interface{}) {
	return {{  printf "%q" .ReboundSQL }}, []interface{}{
		{{- range $param := SortParams .Params }}
		p.{{ ToCamel $param.Name }},
		{{- end }}
	}
}
{{ end }}
{{ end -}}
`))
